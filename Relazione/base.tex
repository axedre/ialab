La prima strategia illustrata è quella più semplice, che useremo come metro di paragone. Ha la proprietà desiderabile di essere Safe, ovvero intraprende sempre un procedimento che porta a un risultato per cui l'UAV riesce a uscire entro il tempo stabilito anche se non è detto che, necessariamente, riesca a massimizzare le inform effettuate nel tempo a disposizione.
La strategia è molto semplice: ci si basa sempre sui controllori implementati nel modulo AGENT, tuttavia non a tutti viene dato il focus a ogni passo dell'UAV, a differenza di quanto detto nella descrizione generica delle strategie nel capitolo \ref{cap:intro}.
In effetti, la principale differenza dalla maggior parte delle altre strategie implementate (e da quanto descritto precedentemente), è che il modulo che si occupa della computazione dei passi non rilascia il focus fino a quando non vengono computati tutti i passi calcolati da A*: questo comporta che i vari controllori vengano azionati solo una volta eseguiti tutti i passi previsti, rendendo la strategia meno adattativa alla variazione di punteggi conseguente alle inform effettuate nel percorso.
Un'altra peculiarità di questa strategia è che viene completamente ignorata la possibilità di effettuare una loiter monitoring per poi compiere una inform precisa sullo stato delle celle. Questo è dovuto al fatto che si volesse implementare una strategia il più possibile semplice da poter poi usare come metro di paragone e confronto con le altre strategia e che avesse, come unica condizione realmente necessaria, la proprietà di essere Safe.
Per poter rendere sufficientemente interessante la strategia si è quindi dovuto ristrutturare la routine di AGENT che, in effetti, si discosta abbastanza da quella basilare illustrata nel capitolo \ref{cap:intro}. Entriamo più nei dettagli illustrando, modulo per modulo, il funzionamento della strategia.
\section{Controllore} \label{sec:base-controllore}
Come detto, vi sono diverse differenze nella routine di controllo nel modulo AGENT rispetto alla strategia generica tratteggiata nel capitolo \ref{cap:intro}. Il modulo AGENT è composto dai seguenti controllori:
\begin{itemize}
	\item individuazione della cella verso cui spostarsi (sezione \ref{sec:base-target})
	\item calcolo del percorso per raggiungere la cella individuata mediante l'algoritmo A* (sezione \ref{sec:base-astar})
	\item controllo del tempo rimanente a partire dal raggiungimento della cella identificata come obiettivo (sezione \ref{sec:base-tempo})
	\item controllo che la cella individuata permetta di raggiungere un'uscita, ai fini di non finire in vicoli ciechi (sezione \ref{sec:base-uscita})
	\item computazione effettiva dei passi calcolati e memorizzati dall'algoritmo A* (sezione \ref{sec:base-movimento})
\end{itemize}
Si noti che il modulo \ref{sec:base-movimento}, come già accennato nell'introduzione di questo capitolo, computa (e consuma) tutti i fatti prodotti dal modulo \ref{sec:base-astar}. Entriamo ora più nel dettaglio dei vari moduli.

\section{Modulo: individuazione della cella target} \label{sec:base-target}
L'individuazione della cella più appetibile nella strategia di base è molto semplice. Durante la fase di inizializzazione dell'ambiente viene assegnato un punteggio a ogni cella, in base alla propria tipologia, e salvato nello slot val del template score\_cell. Questo template serve a memorizzare i punteggi delle celle per individuare la più appetibile presente sulla mappa. I valori, che ricordo non vengono calcolati in questo modulo, bensì nella fase di inizializzazione dell'ambiente, vengono assegnati nel seguente modo: {\color{red}DA COMPLETARE UNA VOLTA STABILITI I PUNTEGGI ESATTI}
\begin{itemize}
	\item Rural: 
	\item Urban: 
	\item Hill: 
	\item Lake: 
	\item Border: 
	\item Gate: 	
\end{itemize}
Il modulo in questione, come prima cosa, si occupa di assegnare, nello slot abs\_score del template score\_cell, un punteggio, per ogni cella, che tenga conto delle tipologie della cella in questione e di quelle limitrofe. Per fare ciò, semplicemente, vengono sommati i valori del campo val delle celle disposte a nord-ovest, nord, nord-est, ovest, est, sud-ovest, sud, sud-est e il campo val della cella in questione, ottenendo un valore che verrà appunto salvato nel campo abs\_score. Viene chiamato abs\_score che sta per "punteggio assoluto", vedremo nell'illustrazione delle altre strategie il perché di questa nomenclatura: in effetti è superfluo l'aggettivo "assoluto" in questa strategia ma, tuttavia, per consistenza nella nomenclatura, si è scelto di mantenere questo nome anche in questo contesto.
Ciò che viene fatto in questo modulo è semplicemente trovare la cella con il punteggio più alto presente in abs\_score e impostarla come target per l'algoritmo A* che verrà computato nel modulo \ref{sec:base-astar}. È importante notare che, in questo procedimento, vengono escluse automaticamente le celle di tipo Hill, Border e Gate (a cui, in effetti, non è nemmeno stato assegnato un valore al campo abs\_score): le prime due per impossibilità di muoversi su celle di quel tipo, l'ultima perché non è desiderabile dirigersi verso una cella di questo tipo fino a quando non si è concluso il compito.
Vengono altresì escluse le celle che sono già state contrassegnate come invalid-target nei moduli \ref{sec:base-uscita} e \ref{sec:base-tempo}.

\section{Modulo: Esecuzione dell'algoritmo A*} \label{sec:base-astar}
{\color{red}SPENDERE DUE PAROLE QUI}

\section{Modulo: Controllo del tempo rimanente} \label{sec:base-tempo}
La principale differenza in questo modulo, rispetto al normale funzionamento in altre strategie, è che il tempo viene calcolato a partire dalla cella che si sta cercando di raggiungere. È noto il tempo rimanente disponibile (dallo slot time del template perc-vision), mediante il modulo \ref{sec:base-astar} è noto anche il tempo che verrà consumato una volta raggiunta la cella desiderata: ad esso viene aggiunto un delta di tempo che tiene in considerazione la possibilità di fare una inform a ogni passo (in questa strategia, quindi, il delta sarà pari a 3 per ogni passo che computerà A*, visto che è necessario fare al più 3 inform a ogni passo dell'UAV). Si detrae, dal tempo rimanente, questo ammontare di tempo necessario a spostarsi verso il target, ottenendo il tempo che rimarrà una volta raggiunto il target. A questo punto viene calcolato il tempo, a partire da quel target, per raggiungere ogni uscita. L'uscita più vicina avrà il tempo inferiore per essere raggiunta quindi si confronta questo tempo con il tempo rimanente una volta raggiunto il target. Se il tempo sarà sufficiente per uscire verrà asserita la condizione di successo del modulo, altrimenti la cella target verrà contrassegnata come invalid-target e, ritraendo i fatti opportuni (astar\_checked e punteggi\_checked {\color{red} EVENTUALMENTE RIGUARDARE SE SI INVERTE L'ORDINE DEI MODULI}), il focus, una volta tornato a AGENT, verrà assegnato nuovamente al modulo \ref{sec:base-target} che questa volta escluderà la cella appena contrassegnata come invalid-target dalle sue computazioni.

\section{Modulo: Controllo di uscita} \label{sec:base-uscita}
Questo modulo si occupa di verificare che, una volta che verrà raggiunto il target trovato, ci sia la possibilità di raggiungere un gate. Questa è un'escamotage studiata al fine di non ritrovarsi in situazioni che portino l'UAV a non poter concludere il suo lavoro (ad esempio finendo in un vicolo cieco dal quale non si possa uscire), con relativa penalità altissima.
Nel caso in cui sia possibile raggiungere una cella di tipo gate dal target stabilito si prosegue normalmente nel flusso dei moduli, asserendo la condizione di successo (exit\_checked). Viceversa, se non fosse possibile raggiungere alcun gate, si aggiunge un fatto che indichi la condizione di impossibilità di uscire da quella cella, in modo che non venga più presa in considerazione nella ricerca di nuovi target papabili; quindi si procede ritraendo il fatto di successo dei moduli \ref{sec:base-tempo}, \ref{sec:base-astar} e \ref{sec:base-target} {\color{red}(CONTROLLARE SE SI CAMBIA L'ORDINE DEI MODULI) }così che il controllore (\ref{sec:base-controllore}), una volta effettuata la pop, dia nuovamente il focus al modulo \ref{sec:base-target} che si occuperà di trovare un nuovo target papabile (scartando la cella trovata precedentemente perché contrassegnata dal fatto che indica l'impossibilità di uscire da quella cella). Come già illustrato nel capitolo \ref{cap:intro} una volta computato A* sappiamo la direzione verso cui l'UAV sarà rivolto una volta arrivato nella cella target: se si scopre che l'UAV non ha la possibilità di uscire, una volta arrivato in quella cella, quella cella nella determinata direzione in cui l'UAV verrebbe a trovarsi viene contrassegnata come illegale con un fatto di tipo invalid-target. Il modulo \ref{sec:base-target} si occupa di escludere le celle così contrassegnate dalla ricerca della cella più appetibile verso cui dirigersi.

\section{Modulo: Movimento} \label{sec:base-movimento}
In questo contesto vengono semplicemente computati i passi dell'UAV prodotti dall'algoritmo A* del modulo \ref{sec:base-astar}. L'algoritmo, come detto, produce fatti di tipo path. In questo modulo essi vengono computati in passi effettivi per l'UAV e ritratti, in modo da mantenere il più pulita possibile la {\color{red}base dei fatti (SI CHIAMA COSÌ?)}.
